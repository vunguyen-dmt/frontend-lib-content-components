{"version":3,"file":"testUtils.js","names":["_reduxMockStore","_interopRequireDefault","require","_reduxThunk","obj","__esModule","default","mockStore","configureMockStore","thunk","createTestFetcher","mockedMethod","thunkAction","args","onDispatch","resolveFn","expectedActions","store","mockReturnValue","Promise","resolve","dispatch","then","undefined","expect","getActions","toEqual","exports","_default"],"sources":["../../../../../src/editors/data/redux/thunkActions/testUtils.js"],"sourcesContent":["/* eslint-disable import/no-extraneous-dependencies */\n/* istanbul ignore file */\nimport configureMockStore from 'redux-mock-store';\nimport thunk from 'redux-thunk';\n\nconst mockStore = configureMockStore([thunk]);\n\n/** createTestFetcher(mockedMethod, thunkAction, args, onDispatch)\n * Creates a testFetch method, which will test a given thunkAction of the form:\n *   ```\n *   const <thunkAction> = (<args>) => (dispatch, getState) => {\n *   ...\n *   return <mockedMethod>.then().catch();\n *   ```\n * The returned function will take a promise handler function, a list of expected actions\n * to have been dispatched (objects only), and an optional verifyFn method to be called after\n * the fetch has been completed.\n *\n * @param {fn} mockedMethod - already-mocked api method being exercised by the thunkAction.\n * @param {fn} thunkAction - thunkAction to call/test\n * @param {array} args - array of args to dispatch the thunkAction with\n * @param {[fn]} onDispatch - optional function to be called after dispatch\n *\n * @return {fn} testFetch method\n *   @param {fn} resolveFn - promise handler of the form (resolve, reject) => {}.\n *     should return a call to resolve or reject with response data.\n *   @param {object[]} expectedActions - array of action objects expected to have been dispatched\n *     will be verified after the thunkAction resolves\n *   @param {[fn]} verifyFn - optional function to be called after dispatch\n */\nexport const createTestFetcher = (\n  mockedMethod,\n  thunkAction,\n  args,\n  onDispatch,\n) => (\n  resolveFn,\n  expectedActions,\n) => {\n  const store = mockStore({});\n  mockedMethod.mockReturnValue(new Promise(resolve => {\n    resolve(new Promise(resolveFn));\n  }));\n  return store.dispatch(thunkAction(...args)).then(() => {\n    onDispatch();\n    if (expectedActions !== undefined) {\n      expect(store.getActions()).toEqual(expectedActions);\n    }\n  });\n};\n\nexport default {\n  createTestFetcher,\n};\n"],"mappings":";;;;;;AAEA,IAAAA,eAAA,GAAAC,sBAAA,CAAAC,OAAA;AACA,IAAAC,WAAA,GAAAF,sBAAA,CAAAC,OAAA;AAAgC,SAAAD,uBAAAG,GAAA,WAAAA,GAAA,IAAAA,GAAA,CAAAC,UAAA,GAAAD,GAAA,KAAAE,OAAA,EAAAF,GAAA;AAHhC;AACA;;AAIA,MAAMG,SAAS,GAAG,IAAAC,uBAAkB,EAAC,CAACC,mBAAK,CAAC,CAAC;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMC,iBAAiB,GAAGA,CAC/BC,YAAY,EACZC,WAAW,EACXC,IAAI,EACJC,UAAU,KACP,CACHC,SAAS,EACTC,eAAe,KACZ;EACH,MAAMC,KAAK,GAAGV,SAAS,CAAC,CAAC,CAAC,CAAC;EAC3BI,YAAY,CAACO,eAAe,CAAC,IAAIC,OAAO,CAACC,OAAO,IAAI;IAClDA,OAAO,CAAC,IAAID,OAAO,CAACJ,SAAS,CAAC,CAAC;EACjC,CAAC,CAAC,CAAC;EACH,OAAOE,KAAK,CAACI,QAAQ,CAACT,WAAW,CAAC,GAAGC,IAAI,CAAC,CAAC,CAACS,IAAI,CAAC,MAAM;IACrDR,UAAU,CAAC,CAAC;IACZ,IAAIE,eAAe,KAAKO,SAAS,EAAE;MACjCC,MAAM,CAACP,KAAK,CAACQ,UAAU,CAAC,CAAC,CAAC,CAACC,OAAO,CAACV,eAAe,CAAC;IACrD;EACF,CAAC,CAAC;AACJ,CAAC;AAACW,OAAA,CAAAjB,iBAAA,GAAAA,iBAAA;AAAA,IAAAkB,QAAA,GAAAD,OAAA,CAAArB,OAAA,GAEa;EACbI;AACF,CAAC"}